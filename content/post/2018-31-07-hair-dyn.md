---
date: 2018-07-31
linktitle: Unity custom hair simulation
title: "Unity : custom hair simulation"
tags : ["unity","dynamics"]
draft : true
toc : true
tocname: "Table of contents:"
---

# Introduction

In today's blog post I would like to talk about hair simulation,
it has been something that always piqued my interest. I attempted to do
a proper simulation in the past based on the
{{<target-blank "Position based dynamics" "http://matthias-mueller-fischer.ch/publications/posBasedDyn.pdf">}},
more specifically the one focusing on
{{<target-blank "inextensible hair strand" "http://matthias-mueller-fischer.ch/publications/FTLHairFur.pdf">}}.

The issue with both papers is that did not worry about keeping the
initial hair shape, basically the groom an artist would have spent
days crafting.
All the demos were with perfectly straight hair (or curly) but that
did not keep the overall shape. I ended up being stuck in trying
to create a stiffness constraint to fix this very problem.

Recently I picked it up the challenge again, this time following the
{{<target-blank "AMD TressFX paper" "/papers/Real-timeHairSimulationwithEfï¬cientHairStylePreservation.pdf">}}.
Special thanks to Dongsoo Han allowing me to upload the paper and use
it for some future tutorials, stay tuned for that!
After going through the paper I was surprised on how close to an
actual working stiffness constraint I got, but more on that later.

In case you are curious about the final result, here below a simulation of a
single hair with quite high stiffness.

![final](../images/02_hairDyn/final.gif)

As you might have understood from the above gif we are going to write this
implementation in Unity, the first pass is going to be in C# on the cpu,
simulating a single hair, in future steps we are going to make a
GPU implementation and having fun optimizing it.

The way I approached this was with a simple Monobehaviour that exposes
pretty much everything needed by the simulation, from positions and masses to
constraints parameters.
The  Evaluation happens in the Update method, although not ideal the correct
time delta is used, VSync is also turned on which led to smooth 60fps.

The computation is composed of four main steps:

- Integration
- Global constraints
- Local constraints
- Edge/Length constraints

Let's get started and explore each one of the stages, building up to our
final simulation.

# Verlet Integration

The integration step is the step in which we compute the forces acting
on each particle and compute the next step in the simulation, basically
answering the question, based on all the information I have know
(forces, positions etc) what will be the state of my system in X time?

The good thing about Verlet integration is that, the velocity is not explicitly
handled like in other integration method like
{{<target-blank "explicit Euler" "https://en.wikipedia.org/wiki/Euler_method">}}

instead the velocity is kept implicit by keeping track of current and previous previous
positions, which allows us to extract the velocity by subtracting the position
at the current frame from the one at previous frame. The nice side effect of
this, is that everything we do that manipulate the positions (constraints),
will implicitly work on the velocity as-well.
All this gives to a much more stable simulation compared to explicit Euler,
only downside is that if you need to handle collision it gets slightly tricky
because to change the velocity you need to manipulate the positions of the
previous frame.

Lets have a quick look on how Verlet integration is implemented,
here the formula:

Where $P_{i+1}$ is the next frame we want to compute, $P_i$ is the positions of the current frame,

$$\begin{align}
P\_{i+1} &= P\_i + V + accel \cdot t^2   \\\\\\
V &= P\_i - P\_{i-1}
\end{align}$$

If you are interested in the actual derivation you can have a look at the great video from
{{<target-blank "Jorgue Rodriguez" "https://www.youtube.com/watch?v=AZ8IGOHsjBk">}}.
The main idea is to start Semi-Implicit Euler integration method, manipulate it, do few
substitution to get a formula based on two sets of positions and not velocities.

Here below the code implementation:

```c#
     public static void verletIntegration( float3[] positions, float3[] outPositions,
                                           float[] invMass, float3 gravity,
                                           float gravityMultiplier,
                                           float damping, float deltaTime)
    {
        int len = positions.Length;
        //for (int i = 0; i < len; ++i)
        for (int i = 0; i < len; ++i)
        {
            //extracting the velocity
            float3 v = positions[i] - outPositions[i];
            v *= damping;
            float3 accel = gravity*gravityMultiplier * invMass[i];
            //computing verlet integration
            outPositions[i] = positions[i] + v + accel*(deltaTime*deltaTime);
        }
    }
```

The above code starts by iterating all the particles one by one and extracting the
velocity. Apologies for the bit confusing naming convention of *positions*
and *outPositions*, I am still trying to figure out a good naming, the fact is
that I am only using two buffers to perform the computation, the *inPosition* buffer
holds the positions for frame $i$ meanwhile outPosition is the second buffer
that holds the positions of $i-1$.
I use the outPosition buffer to extract the velocity then
I override those values since won't be needed anymore.
After the function returns I perform the reference swap.


If you were to run the code now, you would be seeing the particles falling straight
down with no interaction between each other, if that is the case, congratulations
your integration step is working, but we want to simulate hair, we need to have
the particles to be linked with each other, and respect an initial hair length.

Although does not respect the order outlined above, adding edge constraints will allow
us to have an initial simulation, after all the above list is the actual final order
of the algorithm.

# Edge constraints

The edge constraints algorithm used is the same exact one outlined in the Position based
paper. The idea is simple, if the vector between two consecutive particles is longer/shorter
than an initial value, the length will be fixed accordingly.

You can read the constraint explanation directly from the paper, but if you
are like me, I always found that paper hard to digest, the way I understood it was
thanks to the amazing youtube video from a college class. The edge constraint
starts around minute 52.

{{<youtube fH3VW9SaQ_c>}}

The formulation boils down to:

$$\begin{align}
\vec{ n } &= (p\_1 - p\_2) / |(p\_1 - p\_2)|          \\\\\\
\Delta d &= |(p\_1 - p\_2)| - d               \\\\\\
\vec{ \Delta P\_1 } &=  - \frac{w\_1}{(w\_1 + w\_2)} \cdot \Delta d \cdot n        \\\\\\
\vec{ \Delta P\_2 } &=   \frac{w\_2}{(w\_1 + w\_2)} \cdot \Delta d \cdot n         \\\\\\
\end{align}
$$

It does seems like a lot of math, but lets try to unpack equations from $(3)$ to $(7)$ and you will
see that even at an intuitive level will make sense.

Lets start by defining the two points $P\_1$ and $P\_2$, those points are two consecutive
points in our hair.
Next at equation $(3)$ we are just extracting a normalized vector from $P\_1$ to $P\_2$, It
represents the direction we will use to pull/push the particles.

Equation $(4)$ is quite straight forward, we are computing the length of the vector $\vec{P\_1 P\_2}$
and we are subtracting to it $d$ which is the length that the edge should have, also called its
rest length.

Next, in equation $(5)$ we compute a vector that we will use to push both  $P\_1$ and $P\_2$.
The first part of the expression involves $w\_1$ and $w\_2$ which are the inverse masses of
the two point respetively. The argument $\frac{w\_1}{(w\_1 + w\_2)}$ is computing a ratio of
the inverse masses with respect to $P\_1$, equation $(6)$ does the same with respect with
$P\_2$. Once we understood that we see that the two equations boils down to pushing along
the normal vector based on how much we need to push to satisfy the constraint and relative to the
inverse mass of the particle, meaning the smaller $w$ is the less the particle will move, the ligher
it is, the more will be pushed around.

The ratio of the masses sums to one, so to an intuitive level you split the amount we need to push
in two fractions based on the mass, in reality for the hair we use particles with all the same mass
and it simplifies to $\frac{1}{2}$.

After this bit of math, we actually start to have a pretty simulation going, here below an example:


![verlet](../images/02_hairDyn/verlet.gif)

One thing that we need to note is that, since we process the edges one at the time, in a sequential
manner, a point will be pushed around more then once, let's start for example evaluating the first
edge with $P\_0$ and $P\_1$, we apply the constraint, it is satisfied we move to the second constraint,
involving points $P\_1$ and $P\_2$, we satisfy the constraint again, but $P\_1$ moved again, that might
violate the first edge constraint again.

That issue brings us to the concepts of iterating constraints. The system is solved in an iterative way,
rather than a system where all the constraints are satisfied at once. The way it works is that you compute
the constraints of the segments, then you start again and iterate many times, how many will be a parameter defined by the user. Such parameter might be affected by many things, on how strong the simulation is, how strong gravity or how many particle in the hair we have.

# Global constraints
![global](../images/02_hairDyn/global.gif)

** local constraints **
![local](../images/02_hairDyn/local.gif)

** final result **
![final](../images/02_hairDyn/final.gif)
