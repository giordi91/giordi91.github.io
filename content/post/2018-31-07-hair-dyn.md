---
date: 2018-07-31
linktitle: Unity custom hair simulation
title: "Unity : custom hair simulation"
tags : ["unity","dynamics"]
draft : true
toc : true
tocname: "Table of contents:"
---

#Introduction
In today's blog post I would like to talk about hair simulation,
it has been something that always piqued my interest. I attempted to do
a proper simulation in the past based on the
{{<target-blank "Position based dynamics" "http://matthias-mueller-fischer.ch/publications/posBasedDyn.pdf">}},
more specifically the one focusing on
{{<target-blank "inextensible hair strand" "http://matthias-mueller-fischer.ch/publications/FTLHairFur.pdf">}}.

The issue with both papers is that did not worry about keeping the
initial hair shape, basically the groom an artist would have spent
days crafting.
All the demos were with perfectly straight hair (or curly) but that
did not keep the overall shape. I ended up being stuck in trying
to create a stiffness constraint to fix this very problem.

Recently I picked it up the challenge again, this time following the
{{<target-blank "AMD TressFX paper" "/papers/Real-timeHairSimulationwithEfï¬cientHairStylePreservation.pdf">}}.
Special thanks to Dongsoo Han allowing me to upload the paper and use
it for some future tutorials, stay tuned for that!
After going through the paper I was surprised on how close to an
actual working stiffness constraint I got, but more on that later.

In case you are curious about the final result, here below a simulation of a
single hair with quite high stiffness.

![final](../images/02_hairDyn/final.gif)

As you might have understood from the above gif we are going to write this
implementation in Unity, the first pass is going to be in C# on the cpu,
simulating a single hair, in future steps we are going to make a
GPU implementation and having fun optimizing it.

The way I approached this was with a simple Monobehaviour that exposes
pretty much everything needed by the simulation, from positions and masses to
constraints parameters.
The  Evaluation happens in the Update method, although not ideal the correct
time delta is used, VSync is also turned on which led to smooth 60fps.

The computation is composed of four main steps:

- Integration
- Global constraints
- Local constraints
- Edge/Length constraints

Let's get started and explore each one of the stages, building up to our
final simulation.

# Verlet Integration

The integration step is the step in which we compute the forces acting
on each particle and compute the next step in the simulation, basically
answering the question, based on all the information I have know
(forces, positions etc) what will be the state of my system in X time?

The good thing about Verlet integration is that, the velocity is not explicitly
handled like in other integration method like
{{<target-blank "explicit Euler" "https://en.wikipedia.org/wiki/Euler_method">}}

instead the velocity is kept implicit by keeping track of current and previous previous
positions, which allows us to extract the velocity by subtracting the position
at the current frame from the one at previous frame. The nice side effect of
this, is that everything we do that manipulate the positions (constraints),
will implicitly work on the velocity as-well.
All this gives to a much more stable simulation compared to explicit Euler,
only downside is that if you need to handle collision it gets slightly tricky
because to change the velocity you need to manipulate the positions of the
previous frame.

Lets have a quick look on how Verlet integration is implemented,
here the formula:

Where $P_{i+1}$ is the next frame we want to compute, $P_i$ is the positions of the current frame,

$$\begin{align}
P\_{i+1} &= P\_i + V + accel \cdot t^2   \\\\\\
V &= P\_i - P\_{i-1}
\end{align}$$

If you are interested in the actual derivation you can have a look at the great video from
{{<target-blank "Jorgue Rodriguez" "https://www.youtube.com/watch?v=AZ8IGOHsjBk">}}.
The main idea is to start Semi-Implicit Euler integration method, manipulate it, do few
substitution to get a formula based on two sets of positions and not velocities.

Here below the code implementation:

```c#
     public static void verletIntegration( float3[] positions, float3[] outPositions,
                                           float[] invMass, float3 gravity,
                                           float gravityMultiplier,
                                           float damping, float deltaTime)
    {
        int len = positions.Length;
        //for (int i = 0; i < len; ++i)
        for (int i = 0; i < len; ++i)
        {
            //extracting the velocity
            float3 v = positions[i] - outPositions[i];
            v *= damping;
            float3 accel = gravity*gravityMultiplier * invMass[i];
            //computing verlet integration
            outPositions[i] = positions[i] + v + accel*(deltaTime*deltaTime);
        }
    }
```

The above code starts by iterating all the particles one by one and extracting the
velocity. Apologies for the bit confusing naming convention of *positions*
and *outPositions*, I am still trying to figure out a good naming, the fact is
that I am only using two buffers to perform the computation, the *inPosition* buffer
holds the positions for frame $i$ meanwhile outPosition is the second buffer
that holds the positions of $i-1$.
I use the outPosition buffer to extract the velocity then
I override those values since won't be needed anymore.
After the function returns I perform the reference swap.


If you were to run the code now, you would be seeing the particles falling straight
down with no interaction between each other, if that is the case, congratulations
your integration step is working, but we want to simulate hair, we need to have
the particles to be linked with each other, and respect an initial hair length.

This is where we start to talk about edge constraint.

# Edge constraints

![verlet](../images/02_hairDyn/verlet.gif)

** global constraints **
![global](../images/02_hairDyn/global.gif)

** local constraints **
![local](../images/02_hairDyn/local.gif)

** final result **
![final](../images/02_hairDyn/final.gif)
