<!DOCTYPE html>
<html lang="en-US">

<head>
<meta charset="utf-8" />
<meta name="author" content="Marco Giordano" />
<meta name="description" content="A-programmer&#39;s-cave" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.47.1" />

<link rel="canonical" href="/post/resource_compiler/">
<base href="/" />
<meta property="og:title" content="Game engine resource compiler architecture." />
<meta property="og:description" content="Planning the architecture for my first game engine resource compiler 
The ugly model loader If you are not interested in how I ended up with a crappy model loader, jump to the resource compiler section.
Since I started working with OpenGL, almost five years ago, I wrote a super simple and ugly model obj loader. The main issue was that tinyobj loader would give me back multiple index buffers, one per geometry attribute." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/resource_compiler/" /><meta property="article:published_time" content="2019-01-12T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2019-01-12T00:00:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Game engine resource compiler architecture."/>
<meta name="twitter:description" content="Planning the architecture for my first game engine resource compiler 
The ugly model loader If you are not interested in how I ended up with a crappy model loader, jump to the resource compiler section.
Since I started working with OpenGL, almost five years ago, I wrote a super simple and ugly model obj loader. The main issue was that tinyobj loader would give me back multiple index buffers, one per geometry attribute."/>



<meta itemprop="name" content="Game engine resource compiler architecture.">
<meta itemprop="description" content="Planning the architecture for my first game engine resource compiler 
The ugly model loader If you are not interested in how I ended up with a crappy model loader, jump to the resource compiler section.
Since I started working with OpenGL, almost five years ago, I wrote a super simple and ugly model obj loader. The main issue was that tinyobj loader would give me back multiple index buffers, one per geometry attribute.">


<meta itemprop="datePublished" content="2019-01-12T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-01-12T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1010">



<meta itemprop="keywords" content="realtime,engine," />


<script async src="/dist/main.js"></script>
<link rel="stylesheet" href="dist/main.css" />
<style type="text/css">
body {
  background-color: {
     {
      .Param 'colors.background';
    }
  }
  color: {
     {
      .Param 'colors.text';
    }
  }
}

a {
  color: {
     {
      .Param 'colors.link';
    }
  }
}

pre {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
  border: 1px solid {
     {
      .Param 'colors.text';
    }
  }
  border-radius: 5px;
}

code {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
}

blockquote {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
  border-left: 3px solid {
     {
      .Param 'colors.text';
    }
  }
}

table {
  margin: 1em auto;
  border-collapse: collapse;
}

table,
th,
td {
  border: 1px solid {
     {
      .Param 'colors.text';
    }
  }
}

th {
  background: {
     {
      .Param 'colors.text';
    }
  }
  color: {
     {
      .Param 'colors.background';
    }
  }
}

.siteTitle a {
  color: {
     {
      .Param 'colors.main';
    }
  }
}

.post .content h1 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h2 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h3 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h4 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h5 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h6 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content a:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.social-link:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.nav-item-title:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.tag a:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.copyright {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.poweredby {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.poweredby a {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.post-preview .title a {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.content-item a:hover {
  text-decoration: underline;
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post-list .title {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.rmore {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.terms .term a:hover {
  text-decoration: underline;
  color: {
     {
      .Param 'colors.main';
    }
  }
}

</style>



<title>


     Game engine resource compiler architecture. 

</title>

</head>


<body>
<div class="main">
    <header>

        <div class="header-bar">

            <nav>
                <div class="siteTitle">
                    <a href="/">A-programmer&#39;s-cave</a>
                </div> 
                
                
                <a class="nav-item active" href="/post/"><div class="nav-item-title">Posts</div></a>
                
                <a class="nav-item" href="/tags/"><div class="nav-item-title">Tags</div></a>
                

            </nav>
        </div>

        
<div class="social-links-header">

  
  <a href="mailto:myemail"><div class="social-link">email</div></a>
  

  
  <a href="https://github.com/giordi91" target="_blank"><div class="social-link">gh</div></a>
  

  

  
  <a href="https://twitter.com/MGDev91" target="_blank"><div class="social-link">twtr</div></a>
  

  

  <a href="pages/bind.html" target="_blank"><div class="social-link">TheBinder</div></a>

</div>

        <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

		
    </header>


<article class="post">
    <h1 class="title"> Game engine resource compiler architecture. </h1>
		
            
		        Table of contents:
            
		    <nav id="TableOfContents">
<ul>
<li><a href="#the-ugly-model-loader">The ugly model loader</a></li>
<li><a href="#the-resource-compiler">The resource compiler</a></li>
</ul>
</nav>
		
    <div class="content"> 

<p style="background:gray;padding: 1em;">
Planning the architecture for my first game engine resource compiler
</p>

<p><br><br></p>

<h1 id="the-ugly-model-loader">The ugly model loader</h1>

<p>If you are not interested in how I ended up with a crappy model loader,
jump to the resource compiler section.</p>

<p>Since I started working with OpenGL, almost five years ago, I wrote a super simple and ugly model obj loader. The main issue was that  <a href="https://github.com/syoyo/tinyobjloader" target="_blank">tinyobj loader</a>

would give me back multiple index buffers, one per geometry attribute. Inexperienced
and eager to get something on the screen like I was, led me to simply &ldquo;smush&rdquo; (technical term) the
mesh attribute into a single array, and the index buffer became a monotonic increasing
 array like : [1,2,3,4&hellip;.N];</p>

<p>Below is a quick gif of my Qt/OpenGL viewer at the time:</p>

<p><img src="../images/10_resource_compiler/firstOpengl.gif" alt="intro" /></p>

<p>As you can imagine, doing that makes the index buffer useless, as there is
 not a single duplicated index, meaning no vertex cache hits.
 That piece of code was copy-pasted all over my graphics projects, almost untouched for five years. My latest DirectX demos, still run this ugly piece of code:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">for</span> (<span style="color:#6ab825;font-weight:bold">int</span> i = <span style="color:#3677a9">0</span>; i &lt; sz; ++i) {
      <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">auto</span> vtx_id = attr.vertices_ids[i];
      <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">auto</span> uv_id = attr.text_coords_ids[i];
      <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">auto</span> n_id = attr.normals_ids[i];
      <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">auto</span> curr = i * STRIDE;

      vtx[curr + <span style="color:#3677a9">0</span>] = sourceVtx[vtx_id * <span style="color:#3677a9">3</span>];
      vtx[curr + <span style="color:#3677a9">1</span>] = sourceVtx[vtx_id * <span style="color:#3677a9">3</span> + <span style="color:#3677a9">1</span>];
      vtx[curr + <span style="color:#3677a9">2</span>] = sourceVtx[vtx_id * <span style="color:#3677a9">3</span> + <span style="color:#3677a9">2</span>];
      vtx[curr + <span style="color:#3677a9">3</span>] = <span style="color:#3677a9">1.0f</span>;

      vtx[curr + <span style="color:#3677a9">4</span>] = sourceNorm[n_id * <span style="color:#3677a9">3</span>];
      vtx[curr + <span style="color:#3677a9">5</span>] = sourceNorm[n_id * <span style="color:#3677a9">3</span> + <span style="color:#3677a9">1</span>];
      vtx[curr + <span style="color:#3677a9">6</span>] = sourceNorm[n_id * <span style="color:#3677a9">3</span> + <span style="color:#3677a9">2</span>];
      vtx[curr + <span style="color:#3677a9">7</span>] = <span style="color:#3677a9">0.0f</span>;

      vtx[curr + <span style="color:#3677a9">8</span>] = sourceUv[uv_id * <span style="color:#3677a9">2</span>];
      vtx[curr + <span style="color:#3677a9">9</span>] = sourceUv[uv_id * <span style="color:#3677a9">2</span> + <span style="color:#3677a9">1</span>];
      vtx[curr + <span style="color:#3677a9">10</span>] = <span style="color:#3677a9">0.0f</span>;
      vtx[curr + <span style="color:#3677a9">11</span>] = <span style="color:#3677a9">0.0f</span>;

      idx[i] = i;
    }
</code></pre></div>
<p>In particular, in case you did not notice:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#999;font-style:italic">//this is the index buffer
</span><span style="color:#999;font-style:italic"></span>idx[i] = i;
</code></pre></div>
<p>Other than being ugly and slow to render, it was also very slow in reading/loading the resources.
Even for a single skinned character, it would take tens of seconds to load. To the extent that
in my DX11 engine, I added an async resource loader.</p>

<p><img src="../images/10_resource_compiler/asyncload.gif" alt="intro" /></p>

<p>You can see from the gif, the pieces of geometry popping on screen. Don&rsquo;t get me wrong
it was a good exercise but iy did not solve the underlying problem i.e. that my model
loading was crap.</p>

<p>Backtracking a little bit, although in 2018 I focused on graphics a bit, my
2019 resolution was to have graphics as my main focus, stopping any other side projects.
This left me with two graphics projects, my DX11 and DX12 engines.</p>

<p>My DX11 engine is mostly a bunch of code used to get stuff on screen as fast as possible
for the programmer. I wanted my DX12 engine, still in its early stages, to be
a proper engine. I&rsquo;m trying to get a decent architecture.
The implementation of a graphics technique is going to happen in my DX11 engine, until
my DX12 engine will be able to stand on its legs.</p>

<h1 id="the-resource-compiler">The resource compiler</h1>

<p>The need for a decent DX12 engine architecture, made me
fix my model loader, and have a proper resource compiler to process
the resources down to binary, ready to go straight on the GPU at no extra processing needed.</p>

<p>I decided to sit on it for a while and try to architect how it would look like.
Here is what I came up with:</p>

<p><img src="../images/10_resource_compiler/resourceCompiler.jpg" alt="intro" /></p>

<p>Let me try to explain it in a bit more detail now that you have seen a visual
representation of it.</p>

<p>There is a core library for the resource compiler; the library will define several
factors like the interface of the plug-ins (more on that later), how to deal with binary
files, and so on.</p>

<p>This library will then be used in the resource compiler application, which will be in
charge of discovering and registering plug-ins, read-in arguments from command line and
dispatch everything to the correct plug-in.</p>

<p>Now you may be wondering, what are those plug-ins I am talking about? Rather than go with a &ldquo;monolithic&rdquo;
approach, I decided to break it down a little and make it more modular. Each
plug-in will be in charge of processing one type of file, for example, models,
images, skin data.</p>

<p>In reality, I will create small files descriptions of a whole asset, containing
shader, animations, etc, the compiler will unpack such description and dispatch each
resource to the correct plug-in.</p>

<p>The only thing the plug-in needs to do is to export a function called</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">extern</span> <span style="color:#ed9d13">&#34;C&#34;</span>
{
    <span style="color:#6ab825;font-weight:bold">bool</span> RC_PLUGIN pluginRegisterFunction(PluginRegistry *registry);
}
</code></pre></div>
<p>The compiler executable will try to look for all the dlls
inside a plug-in folder and load, as well as execute, such functions.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">void</span> PluginRegistry::loadPlugin(<span style="color:#6ab825;font-weight:bold">const</span> std::string &amp;dllPath) {
  <span style="color:#6ab825;font-weight:bold">auto</span> ws = std::wstring(dllPath.begin(), dllPath.end());
  HMODULE loadedDLL = LoadLibrary(ws.c_str());
  <span style="color:#6ab825;font-weight:bold">if</span> (loadedDLL) {
    <span style="color:#6ab825;font-weight:bold">auto</span> loadFun = (RegisterPluginFunction)GetProcAddress(
        loadedDLL, <span style="color:#ed9d13">&#34;pluginRegisterFunction&#34;</span>);

    <span style="color:#6ab825;font-weight:bold">if</span> (loadFun) {
      <span style="color:#6ab825;font-weight:bold">bool</span> res = loadFun(PluginRegistry::getInstance());
      <span style="color:#6ab825;font-weight:bold">if</span> (res) {
        m_dlls.push_back(loadedDLL);
        SE_CORE_INFO(<span style="color:#ed9d13">&#34;Successfully loaded plug-in {0}&#34;</span>, getFileName(dllPath));
        <span style="color:#6ab825;font-weight:bold">return</span>;
      } <span style="color:#6ab825;font-weight:bold">else</span> {
        SE_CORE_ERROR(<span style="color:#ed9d13">&#34;Problem in loading plug-in {0}&#34;</span>, getFileName(dllPath));
      }
    }
    FreeLibrary(loadedDLL);
  }
}
</code></pre></div>
<p>The loaded function will be executed, its only job is to register the processing
function in the plug-in registry:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">bool</span> <span style="color:#447fcf">pluginRegisterFunction</span>(PluginRegistry *registry) {
  registry-&gt;registerFunction(PLUGIN_NAME, &amp;processModel);
  <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#24909d">true</span>;
}
</code></pre></div>
<p>Where processModel() is of type:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">typedef</span> <span style="color:#447fcf">bool</span> (*ResourceProcessFunction)(<span style="color:#6ab825;font-weight:bold">const</span> std::string &amp;assetPath,
                                        <span style="color:#6ab825;font-weight:bold">const</span> std::string &amp;outputPath
                                        <span style="color:#6ab825;font-weight:bold">const</span> std::string &amp;args);
</code></pre></div>
<p>I am not sure how I want to handle the args for the plug-in, whether I prefer to pre-process
them outside or inside. For the main resource compiler I am using <a href="https://github.com/jarro2783/cxxopts" target="_blank">cxxopts</a>

which works quite well.</p>

<p>This is how an actual compiler invocation is working:</p>

<p><img src="../images/10_resource_compiler/resourceCompilation.jpg" alt="intro" /></p>

<p>The args are fed to the compiler, the compiler will use the plug-in name to access the
registry, and dispatch the plug-in args to the correct plug-in function which will
generate one or more files.</p>

<p>In the next blog post, I will go a bit more in detail on the modelCompilerPlugin and
how I am dealing with the binary file.
Any comments and feedback are more than welcome! I am sure this can be improved
big time!</p>

<p>See you next time.</p>
 </div>

    
<footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="/tags/realtime">#realtime</a>
      </div>
    
      <div class="tag">
        <a href="/tags/engine">#engine</a>
      </div>
    
</div>

    <div class="date"> Jan 12, 2019 </div>
  </div>

</footer>


  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "aprogrammerscave" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:myemail"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/giordi91" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/MGDev91" target="_blank"><div class="social-link">Twitter</div></a>
  

  

  <div class="social-link">
  <a href="/index.xml" target="_blank">RSS</a>
  </div>

</div>


  
<div class="footer-menu">
    
    <a class="footer-menu" href="/comments-policy/">Comments Policy</a>
    
</div>


  <div class="copyright"> Copyright (c) 2018 - present, all rights reserved. </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

