<!DOCTYPE html>
<html lang="en-US">

<head>
<meta charset="utf-8" />
<meta name="author" content="Marco Giordano" />
<meta name="description" content="A-programmer&#39;s-cave" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.47.1" />

<link rel="canonical" href="/post/hairexpansion/">
<base href="/" />
<meta property="og:title" content="Hair expansion in Vertex Shader" />
<meta property="og:description" content="How would you go and expand your hair segment into polygons you can shade? Geometry Shader? Vertex Shader? Introduction The other day I was talking with a friend who was trying to make grass shader, he was going about it by using a geometry shader. Although a geometry shader is a really appealing solution, it might not be the fastest one.
Why not geometry shader? Warning, what I am about to say is mostly what I gathered from the industry, my experience with geometry shader is near to not existent, the only geometry shader I ever implemented was the Nvidia solid wireframe shader ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/hairexpansion/" /><meta property="article:published_time" content="2018-11-05T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-11-05T00:00:00&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hair expansion in Vertex Shader"/>
<meta name="twitter:description" content="How would you go and expand your hair segment into polygons you can shade? Geometry Shader? Vertex Shader? Introduction The other day I was talking with a friend who was trying to make grass shader, he was going about it by using a geometry shader. Although a geometry shader is a really appealing solution, it might not be the fastest one.
Why not geometry shader? Warning, what I am about to say is mostly what I gathered from the industry, my experience with geometry shader is near to not existent, the only geometry shader I ever implemented was the Nvidia solid wireframe shader ."/>



<meta itemprop="name" content="Hair expansion in Vertex Shader">
<meta itemprop="description" content="How would you go and expand your hair segment into polygons you can shade? Geometry Shader? Vertex Shader? Introduction The other day I was talking with a friend who was trying to make grass shader, he was going about it by using a geometry shader. Although a geometry shader is a really appealing solution, it might not be the fastest one.
Why not geometry shader? Warning, what I am about to say is mostly what I gathered from the industry, my experience with geometry shader is near to not existent, the only geometry shader I ever implemented was the Nvidia solid wireframe shader .">


<meta itemprop="datePublished" content="2018-11-05T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2018-11-05T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1566">



<meta itemprop="keywords" content="hlsl,shader,unity," />


<script async src="/dist/main.js"></script>
<link rel="stylesheet" href="dist/main.css" />
<style type="text/css">
body {
  background-color: {
     {
      .Param 'colors.background';
    }
  }
  color: {
     {
      .Param 'colors.text';
    }
  }
}

a {
  color: {
     {
      .Param 'colors.link';
    }
  }
}

pre {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
  border: 1px solid {
     {
      .Param 'colors.text';
    }
  }
  border-radius: 5px;
}

code {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
}

blockquote {
  background: {
     {
      .Param 'colors.code-quote-bg';
    }
  }
  border-left: 3px solid {
     {
      .Param 'colors.text';
    }
  }
}

table {
  margin: 1em auto;
  border-collapse: collapse;
}

table,
th,
td {
  border: 1px solid {
     {
      .Param 'colors.text';
    }
  }
}

th {
  background: {
     {
      .Param 'colors.text';
    }
  }
  color: {
     {
      .Param 'colors.background';
    }
  }
}

.siteTitle a {
  color: {
     {
      .Param 'colors.main';
    }
  }
}

.post .content h1 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h2 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h3 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h4 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h5 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content h6 {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post .content a:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.social-link:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.nav-item-title:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.tag a:hover {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.copyright {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.poweredby {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.poweredby a {
  color: {
     {
      .Param 'colors.copyright';
    }
  }
}
.post-preview .title a {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.content-item a:hover {
  text-decoration: underline;
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.post-list .title {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.rmore {
  color: {
     {
      .Param 'colors.main';
    }
  }
}
.terms .term a:hover {
  text-decoration: underline;
  color: {
     {
      .Param 'colors.main';
    }
  }
}

</style>



<title>


     Hair expansion in Vertex Shader 

</title>

</head>


<body>
<div class="main">
    <header>

        <div class="header-bar">

            <nav>
                <div class="siteTitle">
                    <a href="/">A-programmer&#39;s-cave</a>
                </div> 
                
                
                <a class="nav-item active" href="/post/"><div class="nav-item-title">Posts</div></a>
                
                <a class="nav-item" href="/tags/"><div class="nav-item-title">Tags</div></a>
                

            </nav>
        </div>

        
<div class="social-links-header">

  
  <a href="mailto:myemail"><div class="social-link">email</div></a>
  

  
  <a href="https://github.com/giordi91" target="_blank"><div class="social-link">gh</div></a>
  

  

  
  <a href="https://twitter.com/MGDev91" target="_blank"><div class="social-link">twtr</div></a>
  

  

  <a href="pages/bind.html" target="_blank"><div class="social-link">TheBinder</div></a>

</div>

        <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

		
    </header>


<article class="post">
    <h1 class="title"> Hair expansion in Vertex Shader </h1>
		
            
		        Table of contents:
            
		    <nav id="TableOfContents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#why-not-geometry-shader">Why not geometry shader?</a></li>
<li><a href="#alternatives">Alternatives?</a>
<ul>
<li><a href="#instancing">Instancing</a></li>
<li><a href="#vertex-shader">Vertex shader</a></li>
<li><a href="#turing-mesh-shaders">Turing mesh shaders?</a></li>
</ul></li>
</ul>
</nav>
		
    <div class="content"> 

<p style="background:gray;padding: 1em;">
How would you go and expand your hair segment into polygons you can shade?
Geometry Shader? Vertex Shader?
</p>

<p><img src="../images/09_hairExpansion/hairBallTassellated.gif" alt="hairExp" /></p>

<h1 id="introduction">Introduction</h1>

<p>The other day I was talking with a friend who was trying to make grass shader, he was going about it by using a geometry shader. Although a geometry shader is a really appealing solution, it might not be the fastest one.</p>

<h1 id="why-not-geometry-shader">Why not geometry shader?</h1>

<p>Warning, what I am about to say is mostly what I gathered from the industry, my experience
with geometry shader is near to not existent, the only geometry shader I ever implemented was
the
<a href="http://developer.download.nvidia.com/SDK/10/direct3d/Source/SolidWireframe/Doc/SolidWireframe.pdf" target="_blank">Nvidia solid wireframe shader</a>
.</p>

<p>Although I do plan to go an verify those claims for myself, I did not get around to do so yet,
maybe this will be the time? Who knows. The TL;DR about geometry shaders is that they map quite bad to
the modern pipeline, the not known amount of geometry generated and how the pipeline
is implemented is not really a good fit, in this
<a href="http://www.joshbarczak.com/blog/?p=667" target="_blank">blog post</a>

from  Joshua Barczak you can find
a detail discussion on Geometry shaders.</p>

<p>Don&rsquo;t get me wrong, I am not saying don&rsquo;t use geometry shader at all, I am saying there might be alternatives worth to try.</p>

<h1 id="alternatives">Alternatives?</h1>

<p>The next question, naturally, would be &ldquo;What are those alternatives?&rdquo;. It would be bad of me if I suggest not to go with geometry shaders and don&rsquo;t offer any alternative.</p>

<p>As far as I know, we have few alternatives:</p>

<ul>
<li>Instancing</li>
<li>Vertex Shader</li>
<li>Turing mesh shader?</li>
</ul>

<h2 id="instancing">Instancing</h2>

<p>Instancing is a popular option when you have a lot of geometry to render, the idea being,
you kick the render for a lot of grass blades, and in the vertex shader you use a per instance matrix
to place your mesh in the world.
If your mesh needs to be deformed, you either need to be able to do the simulation for your vertex in the vertex shader, which might limit some options or bind a buffer
with the result of the simulation and fetch the data manually using the vertexID and InstanceID provided.</p>

<p>This is certainly a valid approach, but there is quite a bit of overhead for each geometry if you render a small geometry that overhead might dominate the cost of the render.</p>

<h2 id="vertex-shader">Vertex shader</h2>

<p>Ok, geometry shader and instancing are not ideal, what else we have? We have good old vertex shaders, if what we need to spawn is a simple shape we might be able to generate it procedurally in the VS.</p>

<p>The main idea is that you kick the render of as many vertices you need, then use the SV_vertexID variable in the shader to figure out what point you should output. Let say
you have 10 blades of grass, and the blade of grass is made of 3 quads, each quad is 2 triangles made of 3 vertices, you then want to kick the render for 10*3*6 vertices.
Once in the vertex shader, you want to expand a segment of the hair/grass (2 points), into a camera facing billboard, (2 triangles/6 points).</p>

<p>Let&rsquo;s have a look at how I was doing it in Unity for a hair shader.
Here it is my update method of the Monobehaviour:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">	<span style="color:#6ab825;font-weight:bold">void</span> Update () {

	    <span style="color:#6ab825;font-weight:bold">var</span> data = cmp.getPointDataForRender();
        hairData.SetData(data);

        <span style="color:#6ab825;font-weight:bold">var</span> cam = Camera.main;
        buffer.Clear();
        cam.RemoveCommandBuffer(CameraEvent.AfterForwardOpaque, buffer);

        buffer.SetGlobalBuffer(<span style="color:#ed9d13">&#34;hairData&#34;</span>, hairData);
        buffer.SetGlobalFloat(<span style="color:#ed9d13">&#34;hairWidth&#34;</span>, hairWidth);
        buffer.SetGlobalFloat(<span style="color:#ed9d13">&#34;hairCount&#34;</span>, hairCount);
        buffer.SetGlobalInt(<span style="color:#ed9d13">&#34;hairSegments&#34;</span>, segments);
        buffer.SetGlobalVector(<span style="color:#ed9d13">&#34;cameraView&#34;</span>, cam.transform.localToWorldMatrix.GetColumn(<span style="color:#3677a9">2</span>));
        buffer.DrawProcedural(Matrix4x4.identity,hairMaterial,<span style="color:#3677a9">0</span>,MeshTopology.Triangles, hairCount* segments * <span style="color:#3677a9">6</span>);
        cam.AddCommandBuffer(CameraEvent.AfterForwardOpaque, buffer);
	}</code></pre></div>
<p>As can be seen from the code, what I am doing is fairly straight forward, I am binding a hairData buffer, which contains my simulated hair segments, plus some hair and camera configuration, the renderer is actually kicked by :</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">buffer.DrawProcedural(Matrix4x4.identity,hairMaterial,<span style="color:#3677a9">0</span>,MeshTopology.Triangles, hairCount* segments * <span style="color:#3677a9">6</span>);</code></pre></div>
<p>DrawProcedural() is a specific way of rendering in Unity which does not bind a vertex shader, it will be up to the shader to fetch the data needed to output the hair. The number of vertices I am rendering is:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">hairCount* segments * <span style="color:#3677a9">6</span></code></pre></div>
<p>How does it look like in the vertex shader?</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">v2f <span style="color:#447fcf">vert</span>(uint id : SV_VertexID)
{
    v2f o;
    uint vertexId = id % (<span style="color:#3677a9">6</span>);
    uint hairIndex = id / (hairSegments * <span style="color:#3677a9">6</span>);
    uint vertexInHairIndex = id % (hairSegments * <span style="color:#3677a9">6</span>);
    uint segmentId = vertexInHairIndex / (<span style="color:#3677a9">6</span>);

    <span style="color:#999;font-style:italic">//float globalVertexId = segmentId * 6 + vertexId;
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">//get the tangent of the hair
</span><span style="color:#999;font-style:italic"></span>    float3 tangent = getTangent(segmentId, vertexId, vertexInHairIndex, hairIndex);
    float3 crossV = normalize(cross(tangent.xyz, cameraView.xyz));

    <span style="color:#6ab825;font-weight:bold">int</span> hairGlobalOffset = hairIndex * (hairSegments + <span style="color:#3677a9">1</span>);
    float4 pos = float4(hairData[hairGlobalOffset + segmentId + vertexOffset[vertexId]],<span style="color:#3677a9">1.0f</span>);
    pos.xyz += -crossV* offsets[vertexId]* hairWidth;
    pos.w = <span style="color:#3677a9">1.0f</span>;

    <span style="color:#999;font-style:italic">//filling output
</span><span style="color:#999;font-style:italic"></span>    o.vertex = UnityObjectToClipPos(pos);
    o.worldPos = pos;
    o.tangent = float4(tangent,<span style="color:#3677a9">0.0f</span>);
    <span style="color:#6ab825;font-weight:bold">return</span> o;
}
</code></pre></div>
<p>I am aware that all this indexing in the shader might not be the  easiest to read, but the main idea is, given the SV_VertexID, the first step is to figure out which hair that vertex belongs to, and which segments of that hair.
This can be achieved in the following way:</p>

<p>Which vertex in the segment you are manipulating</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">uint vertexId = id % (<span style="color:#3677a9">6</span>);
</code></pre></div>
<p>Which hair the vertex belongs to</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">uint hairIndex = id / (hairSegments * <span style="color:#3677a9">6</span>);
</code></pre></div>
<p>The local id of the vertex to repsect of your hair:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">uint vertexInHairIndex = id % (hairSegments * <span style="color:#3677a9">6</span>);
</code></pre></div>
<p>And finally your segment id</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">uint segmentId = vertexInHairIndex / (<span style="color:#3677a9">6</span>);
</code></pre></div>
<p>Whit all this data the rest is just generating a billboard facing the camera using the
camera position.</p>

<p>For sake of &ldquo;completeness&rdquo; here the shader configuration:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">uniform StructuredBuffer&lt;float3&gt; hairData : <span style="color:#6ab825;font-weight:bold">register</span>(t0);
float4 cameraView;
<span style="color:#6ab825;font-weight:bold">float</span> hairWidth;
uint hairSegments;
uint hairCount;
<span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">int</span> offsets[<span style="color:#3677a9">6</span>] = { -<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,-<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,-<span style="color:#3677a9">1</span> };
<span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">int</span> vertexOffset[<span style="color:#3677a9">6</span>] = { <span style="color:#3677a9">0</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span> };
<span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">int</span> u[<span style="color:#3677a9">6</span>] = {<span style="color:#3677a9">0</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>};
<span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">int</span> v[<span style="color:#3677a9">6</span>] = {<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">0</span>,<span style="color:#3677a9">1</span>,<span style="color:#3677a9">1</span>};
</code></pre></div>
<p>The various offset arrays are just there to help me figure out without branches how to offset my vertices, I came up with them by writing on paper my two triangles and figuring out
the different offset I would need.</p>

<p>After my first experiment I got something like this:</p>

<p><img src="../images/09_hairExpansion/hairExpansion1.jpg" alt="hairExp1" /></p>

<p>On the left the edit view, with  the hair segment (started with a simple two segment hair), on the right the actual expanded hair.</p>

<p>The main issue is that we get a crack/break at each segment, ideally, we would like to have
the corners of the quads matching. With some extra maths we can actually achieve this, this is the job of the function getTangent which average the two segments, taking care of whether we
are going out of bounds:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#6ab825;font-weight:bold">inline</span> float3 <span style="color:#447fcf">getTangent</span>(<span style="color:#6ab825;font-weight:bold">int</span> segmentId, <span style="color:#6ab825;font-weight:bold">int</span> vertexId, <span style="color:#6ab825;font-weight:bold">int</span> vertexInHairIndex, <span style="color:#6ab825;font-weight:bold">int</span> hairIndex)
{

    <span style="color:#6ab825;font-weight:bold">int</span> hairGlobalOffset = hairIndex * (hairSegments + <span style="color:#3677a9">1</span>);
    <span style="color:#999;font-style:italic">//computing the segment tan
</span><span style="color:#999;font-style:italic"></span>    float3 currentTan = hairData[hairGlobalOffset + segmentId + <span style="color:#3677a9">1</span>] - hairData[hairGlobalOffset+ segmentId];

    <span style="color:#999;font-style:italic">//this value is either 0 or 1, telling us which end of the semgment
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">//we need to grab
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">int</span> vOffset = vertexOffset[vertexId];


    <span style="color:#999;font-style:italic">//base id tells us wheter we need to grab the tangent before the semgnet or
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">//the one after
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">int</span> baseId = vOffset == <span style="color:#3677a9">1</span> ? segmentId +<span style="color:#3677a9">1</span>: segmentId - <span style="color:#3677a9">1</span>;

    <span style="color:#999;font-style:italic">//we need to patch the value to take into account if we are at the start of the semgent
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">//or at the end
</span><span style="color:#999;font-style:italic"></span>    baseId = vertexInHairIndex &lt; <span style="color:#3677a9">2</span> ? segmentId : baseId;
    baseId = vertexInHairIndex == <span style="color:#3677a9">3</span> ? segmentId : baseId;
    baseId = vertexInHairIndex &gt;= ((hairSegments*<span style="color:#3677a9">6</span>)-<span style="color:#3677a9">2</span>)? segmentId : baseId;
    baseId = vertexInHairIndex == ((hairSegments*<span style="color:#3677a9">6</span>)-<span style="color:#3677a9">4</span>)? segmentId : baseId;

    float3 secondaryTan = hairData[hairGlobalOffset + baseId+<span style="color:#3677a9">1</span>] - hairData[hairGlobalOffset+ baseId];
    <span style="color:#6ab825;font-weight:bold">return</span> normalize(currentTan + secondaryTan);
}
</code></pre></div>
<p>This shader is by no mean optimized so probably can be made a lot better, just never got around to do so.</p>

<p>Anyway, this is the result, giving each triangle a different color, made my life much easier for debugging purposes:</p>

<p><img src="../images/09_hairExpansion/hairExpansion2.jpg" alt="hairExp2" /></p>

<p>Once this was working, I extended it to multiple segments:</p>

<p><img src="../images/09_hairExpansion/hairExpansion3.jpg" alt="hairExp3" /></p>

<p>And finally plugged in my hair simulation:</p>

<p><img src="../images/09_hairExpansion/hairBallTassellated.gif" alt="hairExp" /></p>

<p>This technique is the same used by AMD for Tress FX, you can see the amazing result
by playing the rebooted Tomb Raider games. All this is done in vertex shader, with no
overhead of instancing and no geometry shader clunkiness.</p>

<p>With that said, is also true that might be increasingly harder to generate more complex geometries in vertex shader compared to the geometry shader, so this is not a silver bullet.
As a final note on vertex shader, the reader might have noticed that we are generating vertices multiple times, the vertices that are shared in the triangle, of course, this is wasteful,
unluckily I was forced to do this by unity, which does not allow me to use a triangle list for rendering. Having a triangle list, it would have solved the problem of the cracks in-between
segments too.</p>

<h2 id="turing-mesh-shaders">Turing mesh shaders?</h2>

<p>Finally, I wanted to mention the new
<a href="https://www.youtube.com/watch?v=72lYVTlPfI8" target="_blank">Nvidia Turing mesh shader</a>
,
this shader offers unprecedented level of flexibility when it comes to geometry rendering and done in a gpu-friendly way, exploiting the GPGPU/Compute side of it.
The main idea is that you generate work directly on the gpu, you can process chunks of triangles and dynamically
decide to cull them, generates more etc. All this is done in parallel, and you are not limited by the input assembler anymore. Main downside being it is only available through extensions, which makes integration in off the shelf engines like Unity
a really high entry cost as an amount of work needed to integrate. I am really looking forward to trying it in my custom engine.</p>

<p>This is it for now guys! See you next time.</p>
 </div>

    
<footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="/tags/hlsl">#hlsl</a>
      </div>
    
      <div class="tag">
        <a href="/tags/shader">#shader</a>
      </div>
    
      <div class="tag">
        <a href="/tags/unity">#unity</a>
      </div>
    
</div>

    <div class="date"> Nov 5, 2018 </div>
  </div>

</footer>


  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "aprogrammerscave" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:myemail"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/giordi91" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/MGDev91" target="_blank"><div class="social-link">Twitter</div></a>
  

  

  <div class="social-link">
  <a href="/index.xml" target="_blank">RSS</a>
  </div>

</div>


  
<div class="footer-menu">
    
    <a class="footer-menu" href="/comments-policy/">Comments Policy</a>
    
</div>


  <div class="copyright"> Copyright (c) 2018 - present, all rights reserved. </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

